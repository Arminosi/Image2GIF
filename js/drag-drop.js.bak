/**
 * 拖拽排序模块
 * @description 处理文件拖拽排序功能
 */

let dragStartIndex = null;
let dropIndicator = null;

// 添加拖拽事件
function addDragEvents(fileItem) {
    fileItem.addEventListener('dragstart', function(e) {
        dragStartIndex = parseInt(this.dataset.index);
        this.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', dragStartIndex);
    });

    fileItem.addEventListener('dragend', function(e) {
        this.classList.remove('dragging');
        document.querySelectorAll('.file-item').forEach(item => {
            item.classList.remove('drag-over');
        });
        if (dropIndicator) {
            dropIndicator.remove();
            dropIndicator = null;
        }
        dragStartIndex = null;
    });

    fileItem.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        if (dragStartIndex === null) return;
        const currentIndex = parseInt(this.dataset.index);
        if (currentIndex === dragStartIndex) return;

        // 纵向插入逻辑
        const targetRect = this.getBoundingClientRect();
        const containerRect = this.parentElement.getBoundingClientRect();
        const offsetY = e.clientY - targetRect.top;
        const insertBefore = offsetY < targetRect.height / 2;

        // 移除旧指示器
        if (dropIndicator) dropIndicator.remove();

        // 创建新指示器
        dropIndicator = document.createElement('div');
        dropIndicator.className = 'drop-indicator';
        dropIndicator.style.top = (insertBefore ? (this.offsetTop - 2) : (this.offsetTop + this.offsetHeight - 2)) + 'px';
        this.parentElement.appendChild(dropIndicator);
    });

    fileItem.addEventListener('dragleave', function(e) {
        if (dropIndicator) {
            dropIndicator.remove();
            dropIndicator = null;
        }
    });

    fileItem.addEventListener('drop', function(e) {
        e.preventDefault();
        if (dragStartIndex === null) return;
        const currentIndex = parseInt(this.dataset.index);
        const targetRect = this.getBoundingClientRect();
        const offsetY = e.clientY - targetRect.top;
        let insertIndex = offsetY < targetRect.height / 2 ? currentIndex : currentIndex + 1;
        if (dragStartIndex < insertIndex) insertIndex--;
        FileManager.moveFile(dragStartIndex, insertIndex);
        if (dropIndicator) {
            dropIndicator.remove();
            dropIndicator = null;
        }
    });
}

// 导出
window.DragDrop = {
    addDragEvents
};
